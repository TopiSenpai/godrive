package godrive

import (
	"archive/zip"
	"context"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"mime"
	"net/http"
	"net/url"
	"path"
	"strconv"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/jmoiron/sqlx"
	"github.com/topi314/godrive/godrive/auth"
	"github.com/topi314/godrive/godrive/database"
	"github.com/topi314/godrive/internal/http_range"
	"github.com/topi314/godrive/templates"
	"golang.org/x/exp/slices"
)

var ErrUnauthorized = errors.New("unauthorized")

func (s *Server) GetShare(w http.ResponseWriter, r *http.Request) {
	shareID := chi.URLParam(r, "shareID")
	share, err := s.db.GetShare(r.Context(), shareID)
	if err != nil {
		if errors.Is(err, database.ErrShareNotFound) {
			s.error(w, r, err, http.StatusNotFound)
			return
		}
		s.error(w, r, err, http.StatusInternalServerError)
		return
	}

	fullPath := share.Path + strings.TrimPrefix(r.URL.Path, "/share/"+shareID)
	s.getFiles(w, r, fullPath, true)
}

func (s *Server) GetFiles(w http.ResponseWriter, r *http.Request) {
	s.getFiles(w, r, r.URL.Path, false)
}

func (s *Server) getFiles(w http.ResponseWriter, r *http.Request, rqPath string, share bool) {
	fmt.Printf("getFiles: %s\n", rqPath)
	query := r.URL.Query()
	var (
		download    bool
		filesFilter []string
	)
	if dl := query.Get("dl"); dl == "1" || strings.ToLower(dl) == "true" {
		download = true
		if queryFiles := query.Get("files"); queryFiles != "" {
			filesFilter = strings.Split(queryFiles, ",")
		}
	}

	files, err := s.db.FindFiles(r.Context(), rqPath)
	if err != nil {
		s.error(w, r, err, http.StatusInternalServerError)
		return
	}

	if download && len(files) == 0 {
		s.notFound(w, r)
		return
	}

	userInfo := auth.GetUserInfo(r)
	if rqPath != "/" && len(files) == 0 {
		if userInfo.IsGuest() {
			http.Redirect(w, r, "/", http.StatusFound)
			return
		}
		if user, err := s.db.GetUser(r.Context(), userInfo.Subject); err == nil {
			if user.Home != "" && rqPath != user.Home {
				http.Redirect(w, r, user.Home, http.StatusFound)
				return
			}
		}
	}

	if len(files) == 1 && files[0].Path == rqPath {
		file := files[0]

		perms, err := s.auth.GetPermissions(r.Context(), userInfo, file)
		if err != nil {
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}

		if !share && !perms.Has(auth.PermissionRead) {
			s.error(w, r, ErrUnauthorized, http.StatusUnauthorized)
			return
		}

		ra, err := http_range.ParseRange(r.Header.Get("Range"), file.Size)
		if err != nil {
			s.error(w, r, err, http.StatusRequestedRangeNotSatisfiable)
			return
		}
		if download {
			w.Header().Set("Content-Disposition", mime.FormatMediaType("attachment", map[string]string{
				"filename": path.Base(file.Path),
			}))
		}
		w.Header().Set("Content-Type", file.ContentType)
		w.Header().Set("Content-Length", strconv.FormatInt(file.Size, 10))
		w.Header().Set("Accept-Ranges", "bytes")
		if ra != nil {
			w.Header().Set("Content-Range", ra.String())
			w.WriteHeader(http.StatusPartialContent)
		}
		if r.Method == http.MethodHead {
			w.WriteHeader(http.StatusOK)
			return
		}
		if err = s.writeFile(r.Context(), w, file.Path, ra); err != nil {
			slog.ErrorContext(r.Context(), "Failed to write file", slog.Any("err", err))
		}
		return
	}

	filePerms, err := s.auth.GetMultiplePermissions(r.Context(), userInfo, files)
	if err != nil {
		s.error(w, r, err, http.StatusInternalServerError)
		return
	}

	if download {
		zipName := path.Base(rqPath)
		if zipName == "/" || zipName == "." {
			zipName = "godrive"
		}

		w.Header().Set("Content-Disposition", mime.FormatMediaType("attachment", map[string]string{
			"filename": zipName + ".zip",
		}))

		zw := zip.NewWriter(w)
		defer zw.Close()

		rPath := rqPath
		if !strings.HasSuffix(rPath, "/") {
			rPath += "/"
		}

		var totalFiles int
		for _, file := range files {
			if len(filesFilter) > 0 && !slices.Contains(filesFilter, strings.TrimPrefix(file.Path, rPath)) {
				continue
			}

			perms, ok := filePerms[file.Path]
			if !share && (!ok || !perms.Has(auth.PermissionRead)) {
				continue
			}

			fw, err := zw.CreateHeader(&zip.FileHeader{
				Name:               strings.TrimPrefix(file.Path, "/"),
				UncompressedSize64: uint64(file.Size),
				Modified:           file.UpdatedAt,
				Comment:            file.Description,
				Method:             zip.Deflate,
			})
			if err != nil {
				s.error(w, r, err, http.StatusInternalServerError)
				return
			}
			if err = s.writeFile(r.Context(), fw, file.Path, nil); err != nil {
				s.error(w, r, err, http.StatusInternalServerError)
				return
			}
			totalFiles++
		}
		if totalFiles == 0 {
			s.notFound(w, r)
			return
		}
		if err = zw.SetComment("Generated by godrive"); err != nil {
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}
		return
	}

	var templateFiles []templates.File
	for _, file := range files {
		perms, ok := filePerms[file.Path]
		if !share && (!ok || !perms.Has(auth.PermissionRead)) {
			continue
		}

		owner := "Unknown"
		if file.Username != nil {
			owner = *file.Username
		}
		date := file.CreatedAt
		if file.UpdatedAt.After(date) {
			date = file.UpdatedAt
		}

		if dir := strings.TrimPrefix(path.Dir(file.Path), rqPath); dir != "" {
			baseDir := strings.TrimPrefix(dir, "/")
			if strings.Count(baseDir, "/") > 0 {
				baseDir = strings.SplitN(baseDir, "/", 2)[0]
			}
			index := slices.IndexFunc(templateFiles, func(file templates.File) bool {
				return file.Name == baseDir
			})
			if index == -1 {
				templateFiles = append(templateFiles, templates.File{
					IsDir:       true,
					Path:        path.Join(rqPath, baseDir),
					Dir:         rqPath,
					Name:        baseDir,
					Size:        file.Size,
					Date:        date,
					Owners:      []string{owner},
					OwnerIDs:    []string{file.UserID},
					Permissions: perms,
				})
				continue
			}
			templateFiles[index].Size += file.Size
			if templateFiles[index].Date.Before(date) {
				templateFiles[index].Date = date
			}
			if !slices.Contains(templateFiles[index].Owners, owner) {
				templateFiles[index].Owners = append(templateFiles[index].Owners, owner)
			}
			if !slices.Contains(templateFiles[index].OwnerIDs, file.UserID) {
				templateFiles[index].OwnerIDs = append(templateFiles[index].OwnerIDs, file.UserID)
			}
			templateFiles[index].Permissions = templateFiles[index].Permissions.Add(perms)
			continue
		}

		templateFiles = append(templateFiles, s.newTemplateFile(file, perms, nil))
	}

	action := strings.ToLower(query.Get("action"))
	if action == "files" {
		if err = templates.FileList(s.cfg.Auth != nil, templateFiles).Render(r.Context(), w); err != nil {
			slog.ErrorContext(r.Context(), "error executing template", slog.Any("err", err))
		}
		return
	}

	basePath := "/"
	if share {
		basePath = "/share/" + chi.URLParam(r, "shareID")
	}
	vars := templates.IndexVars{
		PathParts: strings.FieldsFunc(rqPath, func(r rune) bool { return r == '/' }),
		Files:     templateFiles,
		Path:      rqPath,
		BasePath:  basePath,
	}
	// fmt.Printf("vars: %+v\n", vars)
	if action == "main" {
		w.Header().Set("HX-Replace-Url", rqPath)
		if err = templates.IndexMain(vars, s.pageVars(r)).Render(r.Context(), w); err != nil {
			slog.ErrorContext(r.Context(), "error executing template", slog.Any("err", err))
		}
		return
	}

	if err = templates.Index(vars, s.pageVars(r)).Render(r.Context(), w); err != nil {
		slog.ErrorContext(r.Context(), "error executing template", slog.Any("err", err))
	}
}

func (s *Server) PostFile(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	action := strings.ToLower(query.Get("action"))

	userInfo := auth.GetUserInfo(r)
	if action == "share" {
		perms, err := s.auth.GetFilePermissions(r.Context(), r.URL.Path, userInfo)
		if err != nil {
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}
		if !perms.Has(auth.PermissionShare) {
			s.error(w, r, ErrUnauthorized, http.StatusUnauthorized)
			return
		}
		shareID := s.auth.NewID(8)
		if err := s.db.CreateShare(r.Context(), database.Share{
			ID:     shareID,
			Path:   r.URL.Path,
			UserID: userInfo.Subject,
		}); err != nil {
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}

		if err := templates.Share(fmt.Sprintf("%s/share/%s", s.cfg.PublicURL, shareID), r.Header.Get("HX-Current-URL")).Render(r.Context(), w); err != nil {
			slog.ErrorContext(r.Context(), "error executing template", slog.Any("err", err))
		}
		return
	}

	if action == "upload" {
		if err := templates.FileUpload(r.URL.Path).Render(r.Context(), w); err != nil {
			slog.ErrorContext(r.Context(), "error executing template", slog.Any("err", err))
		}
		return
	}

	if action == "new-files" {
		files := strings.Split(query.Get("files"), ",")
		uploadFiles := make([]templates.File, 0, len(files))
		for _, file := range files {
			uploadFiles = append(uploadFiles, templates.File{
				Path: path.Join(r.URL.Path, file),
				Name: file,
			})
		}
		if err := templates.UploadFiles(uploadFiles).Render(r.Context(), w); err != nil {
			slog.ErrorContext(r.Context(), "error executing template", slog.Any("err", err))
		}
		return
	}

	if action == "new-permissions" {
		file, err := strconv.Atoi(query.Get("file"))
		if err != nil {
			s.error(w, r, err, http.StatusBadRequest)
			return
		}
		index, err := strconv.Atoi(query.Get("index"))
		if err != nil {
			s.error(w, r, err, http.StatusBadRequest)
			return
		}
		objectType, err := strconv.Atoi(query.Get("object_type"))
		if err != nil {
			s.error(w, r, err, http.StatusBadRequest)
			return
		}
		objectName := query.Get("object_name")
		var object string
		switch objectType {
		case 0:
			user, err := s.db.GetUserByName(r.Context(), objectName)
			if err != nil {
				if errors.Is(err, database.ErrUserNotFound) {
					s.error(w, r, err, http.StatusBadRequest)
					return
				}
				s.error(w, r, err, http.StatusInternalServerError)
				return
			}
			object = user.ID

		case 1:
			object = objectName
		case 2:
			object = ""
			objectName = "Everyone"
		default:
			s.error(w, r, fmt.Errorf("unknown object type: %d", objectType), http.StatusBadRequest)
			return
		}

		if err = templates.PermissionResponse(file, index, templates.Permissions{
			Path:       r.URL.Path,
			ObjectType: auth.ObjectType(objectType),
			Object:     object,
			ObjectName: objectName,
			Map:        templates.UnsetPermissions,
		}, r.URL.Path).Render(r.Context(), w); err != nil {
			slog.ErrorContext(r.Context(), "error executing template", slog.Any("err", err))
		}
		return
	}

	files, err := ParseMultiparts(r)
	if err != nil {
		s.error(w, r, err, http.StatusBadRequest)
		return
	}

	var allPaths []string
	for _, file := range files {
		allPaths = append(allPaths, file.Path())
	}

	dbFiles, err := s.db.GetFiles(r.Context(), allPaths)
	if err != nil {
		s.error(w, r, err, http.StatusInternalServerError)
		return
	}

	missingFiles := []database.File{{Path: r.URL.Path}}
	for _, file := range allPaths {
	innerLoop:
		for _, dbFile := range dbFiles {
			if dbFile.Path == file {
				continue innerLoop
			}
		}
		missingFiles = append(missingFiles, database.File{
			Path: file,
		})
	}

	filePerms, err := s.auth.GetMultiplePermissions(r.Context(), userInfo, append(dbFiles, missingFiles...))
	if err != nil {
		s.error(w, r, err, http.StatusInternalServerError)
		return
	}

	for _, file := range files {
		perms := filePerms[file.Path()]
		if !perms.Has(auth.PermissionCreate) {
			fmt.Printf("unauthorized to create file: %s\n", file.Path())
			s.error(w, r, ErrUnauthorized, http.StatusUnauthorized)
			return
		}

		filePart, err := file.Content()
		if err != nil {
			s.error(w, r, err, http.StatusBadRequest)
			return
		}

		dbFile := database.File{
			Path:        file.Path(),
			Size:        file.Size,
			ContentType: filePart.ContentType,
			Description: file.Description,
			UserID:      userInfo.Subject,
			CreatedAt:   time.Now(),
			UpdatedAt:   time.Now(),
		}

		var tx *sqlx.Tx
		if file.Overwrite {
			tx, err = s.db.UpsertFile(r.Context(), dbFile, file.Permissions.ToDatabase(file.Path()))
		} else {
			tx, err = s.db.CreateFile(r.Context(), dbFile, file.Permissions.ToDatabase(file.Path()))
		}

		if err != nil {
			if errors.Is(err, database.ErrFileAlreadyExists) {
				s.error(w, r, err, http.StatusBadRequest)
				return
			}
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}

		if err = s.storage.PutObject(r.Context(), file.Path(), file.Size, filePart.Reader, filePart.ContentType); err != nil {
			if txErr := tx.Rollback(); txErr != nil {
				slog.ErrorContext(r.Context(), "error rolling back transaction", slog.Any("err", txErr))
			}
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}

		if err = tx.Commit(); err != nil {
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}
	}

	if r.Header.Get("Accept") == "text/html" {
		http.Redirect(w, r, r.URL.Path+"?action=main", http.StatusSeeOther)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

func (s *Server) PatchFile(w http.ResponseWriter, r *http.Request) {
	files, err := s.db.FindFiles(r.Context(), r.URL.Path)
	if err != nil {
		s.error(w, r, err, http.StatusInternalServerError)
		return
	} else if len(files) == 0 {
		s.error(w, r, err, http.StatusNotFound)
		return
	}

	query := r.URL.Query()
	action := strings.ToLower(query.Get("action"))
	userInfo := auth.GetUserInfo(r)
	// update specific file
	if len(files) == 1 && files[0].Path == r.URL.Path {
		dbFile := files[0]

		perms, err := s.auth.GetPermissions(r.Context(), userInfo, dbFile)
		if err != nil {
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}

		if !perms.Has(auth.PermissionUpdate) {
			s.error(w, r, ErrUnauthorized, http.StatusUnauthorized)
			return
		}

		if action == "edit-file" {
			filePerms, err := s.db.GetPermissions(r.Context(), []string{dbFile.Path})
			if err != nil {
				s.error(w, r, err, http.StatusInternalServerError)
				return
			}
			if err = templates.FileEdit(s.newTemplateFile(dbFile, perms, filePerms)).Render(r.Context(), w); err != nil {
				slog.ErrorContext(r.Context(), "error executing template", slog.Any("err", err))
			}
			return
		}

		file, err := ParseMultipart(r)
		if err != nil {
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}

		filePart, err := file.Content()
		if err != nil {
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}

		tx, err := s.db.UpdateFile(r.Context(), database.UpdateFile{
			Path:        r.URL.Path,
			NewPath:     file.Path(),
			Size:        file.Size,
			ContentType: filePart.ContentType,
			Description: file.Description,
			UpdatedAt:   time.Now(),
		}, file.Permissions.ToDatabase(file.Path()))
		if err != nil {
			if errors.Is(err, database.ErrFileNotFound) {
				s.error(w, r, err, http.StatusNotFound)
				return
			}
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}
		if file.Size > 0 {
			if err = s.storage.PutObject(r.Context(), file.Path(), file.Size, filePart.Reader, filePart.ContentType); err != nil {
				if txErr := tx.Rollback(); txErr != nil {
					slog.Error("error rolling back transaction", slog.Any("err", txErr))
				}
				s.error(w, r, err, http.StatusInternalServerError)
				return
			}
			if r.URL.Path != file.Path() {
				if err = s.storage.DeleteObject(r.Context(), r.URL.Path); err != nil {
					if txErr := tx.Rollback(); txErr != nil {
						slog.Error("error rolling back transaction", slog.Any("err", txErr))
					}
					s.error(w, r, err, http.StatusInternalServerError)
					return
				}
			}
		} else if r.URL.Path != file.Path() {
			if err = s.storage.MoveObject(r.Context(), r.URL.Path, file.Path()); err != nil {
				if txErr := tx.Rollback(); txErr != nil {
					slog.Error("error rolling back transaction", slog.Any("err", txErr))
				}
				s.error(w, r, err, http.StatusInternalServerError)
				return
			}
		}

		if err = tx.Commit(); err != nil {
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}

		if r.Header.Get("Accept") == "text/html" {
			http.Redirect(w, r, path.Dir(r.URL.Path)+"?action=main", http.StatusSeeOther)
			return
		}

		w.WriteHeader(http.StatusNoContent)
		return
	}

	var filesFilter []string
	if queryFiles := query.Get("files"); queryFiles != "" {
		filesFilter = strings.Split(queryFiles, ",")
	}
	// update multiple files
	if action == "edit-folder" {
		var queryFiles string
		if len(filesFilter) > 0 {
			queryFiles = "?files=" + url.QueryEscape(strings.Join(filesFilter, ","))
		}
		if err = templates.FolderEdit(r.URL.Path, queryFiles).Render(r.Context(), w); err != nil {
			slog.ErrorContext(r.Context(), "error executing template", slog.Any("err", err))
		}
		return
	}

	destination := r.Header.Get("Destination")
	if destination == "" {
		s.error(w, r, errors.New("missing destination header"), http.StatusBadRequest)
		return
	}

	filePerms, err := s.auth.GetMultiplePermissions(r.Context(), userInfo, append(files, database.File{
		Path: destination,
	}))
	if err != nil {
		s.error(w, r, err, http.StatusInternalServerError)
		return
	}

	perms, ok := filePerms[destination]
	if !ok || !perms.Has(auth.PermissionCreate) {
		s.error(w, r, ErrUnauthorized, http.StatusUnauthorized)
		return
	}

	rPath := r.URL.Path
	if !strings.HasSuffix(rPath, "/") {
		rPath += "/"
	}
	var errs error
	for _, file := range files {
		if len(filesFilter) > 0 && !slices.Contains(filesFilter, strings.SplitN(strings.TrimPrefix(file.Path, rPath), "/", 2)[0]) {
			continue
		}

		perms, ok = filePerms[file.Path]
		if !ok || !perms.Has(auth.PermissionDelete) {
			continue
		}

		newPath := path.Join(destination, strings.TrimPrefix(file.Path, rPath))
		tx, err := s.db.MoveFile(r.Context(), file.Path, newPath)
		if err != nil {
			errs = errors.Join(errs, err)
			continue
		}

		if err = s.storage.MoveObject(r.Context(), file.Path, newPath); err != nil {
			if txErr := tx.Rollback(); txErr != nil {
				slog.Error("error rolling back transaction", slog.Any("err", txErr))
			}
			errs = errors.Join(errs, err)
			continue
		}
	}

	if errs != nil {
		s.error(w, r, errs, http.StatusInternalServerError)
		return
	}

	if r.Header.Get("Accept") == "text/html" {
		http.Redirect(w, r, r.URL.Path+"?action=main", http.StatusSeeOther)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

func (s *Server) DeleteFiles(w http.ResponseWriter, r *http.Request) {
	var filesFilter []string
	if queryFiles := r.URL.Query().Get("files"); queryFiles != "" {
		filesFilter = strings.Split(queryFiles, ",")
	}

	files, err := s.db.FindFiles(r.Context(), r.URL.Path)
	if err != nil {
		return
	}

	if len(files) == 0 {
		s.error(w, r, errors.New("file not found"), http.StatusNotFound)
		return
	}

	userInfo := auth.GetUserInfo(r)
	// delete specific file
	if len(files) == 1 && files[0].Path == r.URL.Path {
		file := files[0]

		perms, err := s.auth.GetPermissions(r.Context(), userInfo, file)
		if err != nil {
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}

		if !perms.Has(auth.PermissionDelete) {
			s.error(w, r, ErrUnauthorized, http.StatusUnauthorized)
			return
		}

		tx, err := s.db.DeleteFile(r.Context(), file.Path)
		if err != nil {
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}
		if err = s.storage.DeleteObject(r.Context(), file.Path); err != nil {
			if txErr := tx.Rollback(); txErr != nil {
				slog.Error("error rolling back transaction", slog.Any("err", txErr))
			}
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}
		if err = tx.Commit(); err != nil {
			s.error(w, r, err, http.StatusInternalServerError)
			return
		}

		if r.Header.Get("Accept") == "text/html" {
			http.Redirect(w, r, path.Dir(r.URL.Path)+"?action=main", http.StatusSeeOther)
			return
		}
		w.WriteHeader(http.StatusNoContent)
		return
	}

	filePerms, err := s.auth.GetMultiplePermissions(r.Context(), userInfo, files)
	if err != nil {
		s.error(w, r, err, http.StatusInternalServerError)
		return
	}

	rPath := r.URL.Path
	if !strings.HasSuffix(rPath, "/") {
		rPath += "/"
	}
	var (
		errs  error
		warns []string
	)
	for _, file := range files {
		if len(filesFilter) > 0 && !slices.Contains(filesFilter, strings.SplitN(strings.TrimPrefix(file.Path, rPath), "/", 2)[0]) {
			continue
		}

		perms, ok := filePerms[file.Path]
		if !ok || !perms.Has(auth.PermissionDelete) {
			warns = append(warns, fmt.Sprintf("unauthorized to delete file: %s", file.Path))
			continue
		}

		tx, err := s.db.DeleteFile(r.Context(), file.Path)
		if err != nil {
			errs = errors.Join(errs, err)
			continue
		}
		if err = s.storage.DeleteObject(r.Context(), file.Path); err != nil {
			if txErr := tx.Rollback(); txErr != nil {
				slog.Error("error rolling back transaction", slog.Any("err", txErr))
			}
			errs = errors.Join(errs, err)
			continue
		}
		if err = tx.Commit(); err != nil {
			errs = errors.Join(errs, err)
		}
	}
	if errs != nil {
		s.error(w, r, errs, http.StatusInternalServerError)
		return
	}
	if len(warns) > 0 {
		s.warn(w, r, strings.Join(warns, ", "), http.StatusOK)
		return
	}

	if r.Header.Get("Accept") == "text/html" {
		http.Redirect(w, r, r.URL.Path+"?action=main", http.StatusSeeOther)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

func (s *Server) writeFile(ctx context.Context, w io.Writer, fullPath string, ra *http_range.Range) error {
	obj, err := s.storage.GetObject(ctx, fullPath, ra)
	if err != nil {
		return err
	}
	defer obj.Close()

	if _, err = io.Copy(w, obj); err != nil {
		return err
	}
	return nil
}
